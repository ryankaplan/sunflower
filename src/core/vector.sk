# This class is partly taken from https://github.com/evanw/theta/blob/master/src/core/vector.sk

enum Axis {
  X
  Y
}

def fmod(a double, b double) double {
  return a - b * Math.floor(a / b)
}

class Vector {
  var x double
  var y double

  def new(x double, y double) {
    self.x = x
    self.y = y
  }

  def clone Vector {
     return new(x, y)
  }

  def - Vector { return new(-x, -y) }

  def +(v Vector) Vector { return new(x + v.x, y + v.y) }
  def -(v Vector) Vector { return new(x - v.x, y - v.y) }
  def *(v Vector) Vector { return new(x * v.x, y * v.y) }
  def /(v Vector) Vector { return new(x / v.x, y / v.y) }
  def %(v Vector) Vector { return new(fmod(x, v.x), fmod(y, v.y)) }

  def +(d double) Vector { return new(x + d, y + d) }
  def -(d double) Vector { return new(x - d, y - d) }
  def *(d double) Vector { return new(x * d, y * d) }
  def /(d double) Vector { return new(x / d, y / d) }
  def %(d double) Vector { return new(fmod(x, d), fmod(y, d)) }

  def +=(v Vector) {
    x += v.x
    y += v.y
  }

  def -=(v Vector) {
    x -= v.x
    y -= v.y
  }

  def *=(v Vector) {
    x *= v.x
    y *= v.y
  }

  def /=(v Vector) {
    x /= v.x
    y /= v.y
  }

  def %=(v Vector) {
    x = fmod(x, v.x)
    y = fmod(y, v.y)
  }

  def +=(d double) {
    x += d
    y += d
  }

  def -=(d double) {
    x -= d
    y -= d
  }

  def *=(d double) {
    x *= d
    y *= d
  }

  def /=(d double) {
    x /= d
    y /= d
  }

  def %=(d double) {
    x = fmod(x, d)
    y = fmod(y, d)
  }

  def set(x double, y double) Vector {
    self.x = x
    self.y = y
    return self
  }

  def set(v Vector) Vector {
    x = v.x
    y = v.y
    return self
  }

  def rotated(angleRad double) Vector {
    return new(
      x * Math.cos(angleRad) - y * Math.sin(angleRad),
      y * Math.cos(angleRad) + x * Math.sin(angleRad)
    )
  }

  # Returns as unit vector
  def normalize Vector {
    return self / self.length
  }

  # Returns the angle of this vector in radians
  def toAngleRad double {
    return Math.atan2(y, x)
  }

  def angleTo(v Vector) double {
    return Math.acos(
      self.normalize.dot(v.normalize)
    )
  }

  def signedAngleTo(v Vector) double {
    return v.toAngleRad - toAngleRad
  }

  def distanceTo(v Vector) double {
    return (self - v).length
  }

  def equals(v Vector) bool {
    return x == v.x && y == v.y
  }

  def length double {
    return Math.sqrt(x * x + y * y)
  }

  def dot(v Vector) double {
    return x * v.x + y * v.y
  }


  def toString string {
    return "Vector(\(x), \(y))"
  }

  def toStringAsInts string {
    return "Vector(\(x as int), \(y as int))"
  }

  def toFloat32Array Float32Array {
    return Float32Array.new([x, y]) }

  def constrainToAspectRatio(other Vector, freeAxis Axis) {
    switch freeAxis {
      case .X {
        x = y * other.x / other.y
      }
      case .Y {
        y = x * other.y / other.x
      }
    }
  }
}

namespace Vector {
  @neverinline
  def new Vector {
    return new(0, 0)
  }
}